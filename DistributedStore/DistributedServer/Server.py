# !/usr/bin/env pythonimport csvimport globimport socketimport sysimport threadingimport timeimport ossys.path.append('./gen-py')from sys import platformif platform == "linux" or platform == "linux2":    sys.path.insert(0, glob.glob('/home/yaoliu/src_code/local/lib/lib/python2.7/site-packages')[0])from thrift.transport import TSocketfrom thrift.transport import TTransportfrom thrift.protocol import TBinaryProtocolfrom thrift.server import TServerfrom thrift import Thriftfrom DistributedStore import DistributedStorefrom DistributedStore.ttypes import  NodeID, SystemException, MetaData, Data, MsgWrite, MsgRead,MsgWriteRepairimport logginglogging.basicConfig(level=logging.DEBUG)from pathlib import Pathclass DistributedStoreHandler:    def __init__(self, nodeId):        self.fingerTable = None        self.replicas = None        self.nodeId = nodeId        self.memTable = {} #key --> value        self.transStatusMsgs = {} # transId -- > msg        self.replicaStatus = {} # replica.id --> {status:A / D , hints:}        # self.writeHints = {} # replica.id --> [keys]        print(self.nodeId)        self.memTableLock = threading.RLock()        self.transStatusMsgsLock = threading.RLock()        self.replicaStatusLock = threading.RLock()        self.config = None        self.initServer()    def initServer(self):        server = self.nodeId.ip + ':' + str(self.nodeId.port)        path = os.path.join('temp', 'data')        Path(path).mkdir(parents=True, exist_ok=True)        path = os.path.join('temp', 'log')        Path(path).mkdir(parents=True, exist_ok=True)        path = os.path.join('temp', 'status')        Path(path).mkdir(parents=True, exist_ok=True)        with open('store.config') as config:            l = config.readline()            l = l.strip().split(sep=':')            config = l[1].strip()            self.config = config        self.readDataFromStorageFile()    def createWriter(self,name,fields):        file = Path(name)        isExists = file.exists()        csvfile = open(name, 'a', newline='')        writer = csv.DictWriter(csvfile, fieldnames=fields)        if not isExists:            # print('writing headers ', name)            writer.writeheader()        return writer,csvfile    def writeDataToStorageFile(self, data):        '''        Always use with memTableLock        :param data:        :return:        '''        # 'Key', 'TimeStamp', 'Value','Owner','Time'        server = self.nodeId.ip + ':' + str(self.nodeId.port)        name = os.path.join('temp','data',server + '.data')        fields = ['Key', 'TimeStamp','Owner', 'Value']        dataWriter,dataFile = self.createWriter(name, fields)        logEntry = {'Key':data.key, 'TimeStamp':data.metaData.timeStamp, 'Value':data.value,                    'Owner':data.metaData.owner.ip+':'+str(data.metaData.owner.port), }        # print('in writeDataToStorage ', logEntry)        dataWriter.writerow(logEntry)        dataFile.close()    def readDataFromStorageFile(self):        server = self.nodeId.ip + ':' + str(self.nodeId.port)        name = os.path.join('temp', 'data', server + '.data')        try:            with open(name,'r') as f:                reader = csv.DictReader(f)                for row in reader:                    # 'Key', 'TimeStamp', 'Value','Owner',                    owner = row['Owner'].split(sep=':')                    id = decode_sha256(row['Owner'])                    owner = NodeID(id=id,ip=owner[0],port=int(owner[1]))                    meta = MetaData(owner=owner,timeStamp=row['TimeStamp'])                    data = Data(key=int(row['Key']),value=row['Value'],metaData=meta)                    self.writeDataToMemory(data)        except FileNotFoundError:            pass        finally:            pass    def logWriteTransaction(self,tranSId,data):        server = self.nodeId.ip + ':' + str(self.nodeId.port)        name = os.path.join('temp','log',server + '.log')        fields = ['Transaction', 'Key', 'TimeStamp', 'Value']        logWriter,log = self.createWriter(name, fields)        logEntry = {'Transaction':tranSId, 'Key':data.key, 'TimeStamp':data.metaData.timeStamp, 'Value':data.value}        # print('in logWriteTransaction ',logEntry)        logWriter.writerow(logEntry)        log.close()    def logTransactionStatus(self, tranSId, msg):        # fields = ['Transaction', 'Server', 'Status']        server = self.nodeId.ip + ':' + str(self.nodeId.port)        name = os.path.join('temp', 'status', server + '.status')        fields = ['Transaction', 'Server', 'Key', 'Status']        statusWriter, statusFile = self.createWriter(name, fields)        server = msg.server.ip + ':' + str(msg.server.port)        logEntry = {'Transaction': tranSId, 'Server': server, 'Status': msg.status, 'Key': msg.key}        # print('in logTransactionStatus ', logEntry)        statusWriter.writerow(logEntry)        statusFile.close()    def getHintsFromLogs(self):        server = self.nodeId.ip + ':' + str(self.nodeId.port)        logname = os.path.join('temp', 'log', server + '.log')        statusName = os.path.join('temp', 'status', server + '.status')        try:            with open(logname,'r') as logFile,open(statusName,'r') as statusfile:                logReader = csv.DictReader(logFile)                mostRecentData = {}                for row in logReader:                    # 'Transaction', 'Key', 'TimeStamp', 'Value'                    meta = MetaData(owner=self.nodeId, timeStamp=row['TimeStamp'])                    data = Data(key=int(row['Key']),value=row['Value'],metaData=meta)                    if row['Key'] not in mostRecentData:                        mostRecentData[int(row['Key'])] = (data,row['Transaction'])                    elif float(mostRecentData[int(row['Key'])].metadata.timeStamp) < float(row['TimeStamp']):                        mostRecentData[int(row['Key'])] = (data,row['Transaction'])                # print('getHintsFromLogs mostRecentData:' ,mostRecentData)                if mostRecentData:                    mostRecentTrasIds = [mostRecentData[recentData][1] for recentData in mostRecentData]                    statusReader = csv.DictReader(statusfile)                    for row in statusReader:                        # fields = ['Transaction', 'Server', 'Key','Status']                        if row['Transaction'] in mostRecentTrasIds and row['Status'] == 'Failed':                            server = row['Server'].split(sep=':')                            id = decode_sha256(row['Server'])                            serverId = NodeID(id=id, ip=server[0], port=int(server[1]))                            self.checkInit()                            # print("In getHintsFromLogs before lock replicaStatusLock ",threading.currentThread().getName(), 'Exiting')                            with self.replicaStatusLock:                                # print("In getHintsFromLogs after lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')                                self.replicaStatus[id]['status'] = 'D'                                self.replicaStatus[id]['hints'].append(int(row['Key']))                            # print("In getHintsFromLogs after release lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')                    # print('Replica Status From Logs : ', self.replicaStatus)        except FileNotFoundError:            pass        finally:            pass    def writeDataToMemory(self,data):        entered = False        # print("In writeDataToMemory before lock memTableLock",threading.currentThread().getName(), 'Exiting')        with self.memTableLock:            # print("In writeDataToMemory after lock memTableLock",threading.currentThread().getName(), 'Exiting')            if data.key in self.memTable:                # print('Writing Duplicated Data: ', data)                prevData = self.memTable[int(data.key)]                if float(prevData.metaData.timeStamp) < float(data.metaData.timeStamp):                    self.memTable[int(data.key)] = data                    # print('Writing Data: ', data)                    entered = True            else:                self.memTable[int(data.key)] = data                # print('Writing Data: ', data)                entered = True        # print("In writeDataToMemory after release lock memTableLock",threading.currentThread().getName(), 'Exiting')        return  entered    def write(self, data, transactionId):        """        Parameters:         - data         - transactionId        """        print('\t\twriting to this replica for key',data.key)        writeMsg = MsgWrite(transactionId=str(transactionId), server=self.nodeId, status="Success",key=int(data.key))        try:            # print("In write before lock memTableLock",threading.currentThread().getName(), 'Exiting')            self.memTableLock.acquire()            # print("In write after lock memTableLock",threading.currentThread().getName(), 'Exiting')            if self.writeDataToMemory(data):                self.writeDataToStorageFile(data)            self.memTableLock.release()            # print("In write after release lock memTableLock",threading.currentThread().getName(), 'Exiting')            owner = data.metaData.owner            if owner.id == self.nodeId.id:                self.setWriteStatus(transactionId, writeMsg)            else:                try:                    # print('\t\t Send bsck write status ')                    ownerServer, ownerTrasport = self.connectToNode(owner)                    if ownerServer:                        ownerServer.setWriteStatus(str(transactionId), writeMsg)                        # ownerTrasport.close()                except:                    pass        finally:            print('\t\tstate write status done with ',writeMsg.status)    def writeToAllReplicas(self, key,value, consistency):        """        Parameters:         - data         - consistency        """        localTime = str(time.time())        metaData = MetaData(owner=self.nodeId, timeStamp=str(localTime))        data = Data(key=int(key), value=str(value), metaData=metaData)        transId = 'W_'+str(data.key)+'_'+str(localTime)        self.logWriteTransaction(transId,data)        self.transStatusMsgs[transId] = []        print('88************************ WRITE TO ALL START********************************************************')        try:            self.checkInit()            for replica in self.replicas:                if replica.id == self.nodeId.id:                    # print('For Replicas This ', replica.port)                    t = threading.Thread(target=self.write, args=(data, transId),                                         name='WriteReplica' + str(replica.port))                    t.setDaemon(True)                    t.start()                    # self.write(data, transactionId=transId)                else:                    # print('\tFor Replicas RPC ', replica.port)                    replicaServer, replicaTransport = self.connectToNode(replica,True)                    # replicaServer.write(data,str(transId))                    if replicaServer:                        t = threading.Thread(target=replicaServer.write, args=(data, transId),                                             name='WriteReplica' + str(replica.port))                        t.setDaemon(True)                        t.start()                    else:                        print('\tConnection not found in Write for ' , replica.port)                        writeMsg = MsgWrite(transactionId=str(transId), server=replica, status="Failed",key=int(data.key))                        self.setWriteStatus(transId,writeMsg)                    # replicaTransport.close()        finally:            # serverTransport.close()            success = self.requestWriteTransactionStatus(transId, consistency)            print('88************************ WRITE TO ALL END********************************************************')            if not success:                raise SystemException(message='Write Failed: Data not saved to all replicas')    def requestWriteTransactionStatus(self, transId, consistency):        # print('\tRequesting requestWriteTransactionStatus')        self.checkInit()        success = False        while 1:            count, total = self.getSuccessCount(transId)            if count >= consistency:                success = True                break            elif total >= len(self.replicas):                break        return success    def getSuccessCount(self, transactionId):        # print("In getSuccessCount before lock transStatusMsgsLock",threading.currentThread().getName(), 'Exiting')        self.transStatusMsgsLock.acquire()        # print("In getSuccessCount after lock transStatusMsgsLock",threading.currentThread().getName(), 'Exiting')        count = 0        total = 0 #len(self.trasactions[transactionId])        for msg in self.transStatusMsgs[transactionId]:            total += 1            if msg.status == 'Success':                count = count + 1                # print('count:', count, 'total ', total, 'sever', msg.server.port)        self.transStatusMsgsLock.release()        # print("In getSuccessCount after release lock transStatusMsgsLock",threading.currentThread().getName(), 'Exiting')        return count, total    def setWriteStatus(self, transactionId, msg):        # print('\t\t###################################################################################')        print('\t\tWrite Status', msg.server.port,'  ' ,msg.status)        # print("In setWriteStatus before lock transStatusMsgsLock",threading.currentThread().getName(), 'Exiting')        with self.transStatusMsgsLock:            # print("In setWriteStatus after lock transStatusMsgsLock",threading.currentThread().getName(), 'Exiting')            self.logTransactionStatus(tranSId=transactionId,msg=msg)            self.transStatusMsgs[transactionId].append(msg)        # print("In setWriteStatus after release lock transStatusMsgsLock",threading.currentThread().getName(), 'Exiting')        self.checkInit()        if self.config == 'HINTED_HANDOFF':            # print("In setWriteStatus before lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')            self.replicaStatusLock.acquire()            # print("In setWriteStatus after lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')            if msg.status == 'Failed':                self.replicaStatus[msg.server.id]['status'] = 'D'                self.replicaStatus[msg.server.id]['hints'].append(msg.key)            self.replicaStatusLock.release()            # print("In setWriteStatus after release lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')    def readToAllReplicas(self, data, consistency):        """        Parameters:         - data         - consistency        """        localTime = str(time.time())        data.metaData.timeStamp = localTime        # transId = decode_sha256(str(data.key) + str(time))        transId = str(data.key) + '_' + str(localTime)        # transId = decode_sha256(str(data.key) + str(data.metaData.timeStamp))        self.transStatusMsgs[transId] = []        print('**************** START READ ALL Replicas **************************************')        try:            for replica in self.replicas:                # print('For EACH Replicas READ', replica.port)                if replica.id == self.nodeId.id:                    # print('For Replicas This READ', replica)                    t = threading.Thread(target=self.read, args=(data, transId),                                         name='ReadReplica' + str(replica.port))                    t.setDaemon(True)                    t.start()                    # self.write(data, transactionId=transId)                else:                    # print('For Replicas RPC ', replica.port)                    replicaServer, replicaTransport = self.connectToNode(replica,True)                    if replicaServer:                        # replicaServer.write(data,str(transId))                        t = threading.Thread(target=replicaServer.read, args=(data, transId),                                             name='ReadReplica' + str(replica.port))                        t.setDaemon(True)                        t.start()                    else:                        readMsg = MsgRead(transactionId=str(transId), server=replica, status="Failed", data=None)                        self.setReadStatus(transId,readMsg)                    # replicaTransport.close()        finally:            # serverTransport.close()            success,data = self.requestReadTransactionStatus(transId, consistency)            if not success:                raise SystemException(message='Read Failed: Data not saved to all replicas')            else:                return data.value            # t = threading.Thread(target=self.requestTransactionStatus, args=(transId, consistency),            #                      name='RequestStatus' + str(transId))            # t.start()    def requestReadTransactionStatus(self, transId, consistency):        success = False        readData = None        while 1:            # print("In requestReadTransactionStatus before lock transStatusMsgsLock",threading.currentThread().getName(), 'Exiting')            with self.transStatusMsgsLock:                count, total = self.getSuccessCount(transId)                if count >= consistency:                    success = True                    readData = self.getMostRecentData(self.transStatusMsgs[transId])                    break                elif total >= len(self.replicas):                    break            # try:            #     # print("In requestReadTransactionStatus after lock transStatusMsgsLock",threading.currentThread().getName(), 'Exiting')            #            #     count, total = self.getSuccessCount(transId)            #     if count >= consistency:            #         success = True            #         readData = self.getMostRecentData(self.transStatusMsgs[transId])            #         break            #     elif total >= len(self.replicas):            #         break            # # except:            # #     pass            # finally:            #     self.transStatusMsgsLock.release()            # # print("In requestReadTransactionStatus after release lock transStatusMsgsLock",threading.currentThread().getName(), 'Exiting')        return success,readData    def read(self, data, transId):        # print('Read to this replica')        readMsg = MsgRead(transactionId=str(transId), server=self.nodeId, status="Success", data=None)        try:            # print("In read before lock memTableLock",threading.currentThread().getName(), 'Exiting')         # self.memTableLock.acquire()            with self.memTableLock:                # print("In read after lock memTableLock",threading.currentThread().getName(), 'Exiting')                if data.key in self.memTable:                    storedData = self.memTable[int(data.key)]                    # print('Read FOUND to this replica : ', storedData)                    readMsg.data = storedData                    readMsg.status = 'Success'                # self.memTableLock.release()            # print("In read after release lock memTableLock",threading.currentThread().getName(), 'Exiting')            owner = data.metaData.owner            if owner.id == self.nodeId.id:                self.setReadStatus(transId, readMsg)            else:                ownerServer, ownerTrasport = self.connectToNode(owner)                if ownerServer:                    ownerServer.setReadStatus(str(transId), readMsg)                    ownerTrasport.close()        except:            pass        # print('Read to this replica done with status',readMsg.status)    def setReplicationtable(self, replica_node_list):        """        Parameters:         - finger_node_list         - replica_node_list        """        self.replicas = replica_node_list        if self.config == 'HINTED_HANDOFF':            # print("In setReplicationtable before lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')            with self.replicaStatusLock:                # print("In setReplicationtable after lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')                if not self.replicaStatus:                    self.replicaStatus = {replica.id: {'status': 'A', 'hints':[]} for replica in self.replicas}                    self.getHintsFromLogs()            # print("In setReplicationtable before after release replicaStatusLock",threading.currentThread().getName(), 'Exiting')        # print('finger replicas', self.replicas)    def getReplicas(self):        return self.replicas    def connectToNode(self, node,runRepair = False):        # Make socket        # print('connectToNode Connecting to ....', node.port)        client = None        transport = TSocket.TSocket(node.ip, int(node.port))        transport = TTransport.TBufferedTransport(transport)        protocol = TBinaryProtocol.TBinaryProtocol(transport)        try:            client = DistributedStore.Client(protocol)            transport.open()            if runRepair and self.config == 'HINTED_HANDOFF':                t = threading.Thread(name='conn_runWriteRepair'+node.ip+':'+str(node.port) , target= self.runWriteRepair,                                 args=(node,))                t.setDaemon(True)                # print('connectToNode starting conn_runWriteRepair')                t.start()        except Exception as e:            client = None            # print('connectToNode Connection Failed with',e)        return client, transport    def setReadStatus(self, transId, readMsg):        # print('###################################################################################')        print('Read Status', readMsg, '')        self.checkInit()        self.transStatusMsgs[transId].append(readMsg)        if len(self.transStatusMsgs[transId]) == len(self.replicas) and self.config == 'READ_REPAIR':            t = threading.Thread(name='runReadRepair'+self.nodeId.ip+':'+str(self.nodeId.port) , target= self.runReadRepair,                             args=(transId,))            t.setDaemon(True)            # print('setReadStatus starting conn_runReadRepair')            t.start()    def runReadRepair(self, transId):        readData = self.getMostRecentData(self.transStatusMsgs[transId])        # print('runReadRepair Most Recent data', readData)        for replica in self.replicas:            if replica.id == self.nodeId.id:                self.readRepair(readData)            else:                replicaServer, replicaTransport = self.connectToNode(replica)                if replicaServer:                    replicaServer.readRepair(readData)    def getMostRecentData(self, transMsgs):        mostRecentData = None        # print('In getMostRecentData')        for msg in transMsgs:            if msg.data:                if not mostRecentData:                    mostRecentData = msg.data                elif float(msg.data.metaData.timeStamp) > float(mostRecentData.metaData.timeStamp):                    mostRecentData = msg.data        return mostRecentData    def runWriteRepair(self,server,tempDataHints=None):        # print('runWriteRepair args',server,tempDataHints)        if not tempDataHints:            tempDataHints = self.memTable        # print("In runWriteRepair before lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')        with self.replicaStatusLock:            # print("In runWriteRepair after lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')            status = self.replicaStatus[server.id]['status']            dataHints = [tempDataHints[int(key)] for key in self.replicaStatus[server.id]['hints']]        # print("In runWriteRepair after realease lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')        # print('runWriteRepair dataints',dataHints , 'with status ', status )        if 'D' == status:            # self.replicaActiveStatus[server.id]['status'] = 'A'            serverConn,transport = self.connectToNode(server)            transId = 'WRepair'+'_'+server.ip+':'+str(server.port)            # print('Data hints for : ',server.port,'  ',dataHints)            if serverConn:                # print('Data hints for sending server: ', server.port, '  ', dataHints)                serverConn.writeRepair(transId=transId,dataHints=dataHints,coordinator=self.nodeId)            elif server == self.nodeId:                # print('Data hints for  sending self: ', server.port, '  ', dataHints)                self.writeRepair(transId=transId,dataHints=dataHints,coordinator=self.nodeId)    def writeRepair(self, dataHints, transId, coordinator):        # print('WriteRepair dataints', dataHints)        for data in dataHints:            # print("In writeRepair before lock memTableLock",threading.currentThread().getName(), 'Exiting')            self.memTableLock.acquire()            try:                # print("In writeRepair before lock memTableLock",threading.currentThread().getName(), 'Exiting')                if self.writeDataToMemory(data):                    self.writeDataToStorageFile(data)            finally:                self.memTableLock.release()            # print("In writeRepair before lock memTableLock",threading.currentThread().getName(), 'Exiting')        coServer,transport = self.connectToNode(coordinator)        if coServer:            msg = MsgWriteRepair(transactionId=transId,server=self.nodeId,status='Sucesss')            coServer.setWriteRepair(transId,msg)    def setWriteRepair(self,transId,msg):        # print('setWriteRepair ')        # print("In setWriteRepair before lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')        with self.replicaStatusLock:            # print("In setWriteRepair after lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')            self.replicaStatus[msg.server.id]['hints']=[]            self.replicaStatus[msg.server.id]['status'] = 'A'        # print("In setWriteRepair after release lock replicaStatusLock",threading.currentThread().getName(), 'Exiting')    def readRepair(self, data):        """        Parameters:         - data         - transId         - coordinator        """        # print("In read reapair before lock memTableLock",threading.currentThread().getName(), 'Exiting')        with self.memTableLock:            # print("In read reapair after lock memTableLock",threading.currentThread().getName(), 'Exiting')            if self.writeDataToMemory(data=data):                self.writeDataToStorageFile(data=data)        # print("In read reapair after lock release memTableLock",threading.currentThread().getName(), 'Exiting')        pass    def checkInit(self):        if not self.replicas:            print('##################PLEASE INIT####################')def decode_sha256(s):    import hashlib    sha256 = hashlib.sha256()    sha256.update(s.encode())    return sha256.hexdigest()if __name__ == '__main__':    port = sys.argv[1]    ip = socket.gethostbyname(socket.getfqdn())    if platform == "win32":        from random import randint, seed        seed()        port = randint(5000, 9999)        handler = DistributedStoreHandler(NodeID(id=decode_sha256(ip + ":" + str(port)), ip=ip, port=port))    else:        handler = DistributedStoreHandler(NodeID(id=decode_sha256(ip + ":" + port), ip=ip, port=int(port, 10)))    processor = DistributedStore.Processor(handler)    transport = TSocket.TServerSocket(port=port)    tfactory = TTransport.TBufferedTransportFactory()    pfactory = TBinaryProtocol.TBinaryProtocolFactory()    # server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)    # # You could do one of these for a multithreaded server    server = TServer.TThreadedServer(        processor, transport, tfactory, pfactory)    # server = TServer.TThreadPoolServer(    #     processor, transport, tfactory, pfactory)    print('Starting the server...')    server.serve()    print('done.')